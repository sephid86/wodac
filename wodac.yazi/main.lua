local ya = require("yazi")
local shell = require("yazi.shell")

local INSTALL_DIR = os.getenv("HOME") .. "/.local/bin"
local SCRIPT_PATH = INSTALL_DIR .. "/wodac.sh"

-- Helper function to run CLI commands (async via os.execute)
local function run_cli(cmd)
    os.execute(cmd .. " >/dev/null 2>&1")
end

-- 설치 함수: wodac.sh 스크립트 내용을 파일로 생성
local function install_script(plug)
    local script_content = [[
#!/bin/bash
# wodac (Wofi Default App Chooser) - Generated by Yazi Plugin

#  - 저작권 및 라이선스 / Copyright and License -

# Copyright (C) 2025 AI on Google Search (Gemini) (as the developer of the underlying AI model)

# 이 스크립트는 AI on Google Search (Gemini)에 의해 작성되었으며 GPLv3 라이선스 하에 배포됩니다. 자세한 내용은 스크립트 파일을 참조하십시오.

# This script was authored by AI on Google Search (Gemini) and is distributed under the GNU General Public License v3.0. See the script file for full details.

FILE_PATH="$1"
MAP_FILE="/tmp/wofi_path_map.txt"
rm -f "$MAP_FILE"

if [ -z "$FILE_PATH" ]; then
    notify-send "Wodac 오류/Error" "처리할 파일 경로가 제공되지 않았습니다. (No file path provided)"
    exit 1
fi

CURRENT_MIME=$(xdg-mime query filetype "$FILE_PATH")
if [ -z "$CURRENT_MIME" ]; then
    notify-send "Wodac 오류/Error" "선택한 파일의 MIME 타입을 알 수 없습니다. (Cannot detect MIME type)"
    exit 1
fi

process_list() {
    local list="$1"
    for full_path in $list; do
        app_name=$(grep "^Name=" "$full_path" | cut -d'=' -f2 | head -n 1 | tr -d '\n')
        if [ -n "$app_name" ]; then
            echo "$app_name:$full_path" >> "$MAP_FILE"
        fi
    done
}

# --- Yazi 내장 로직과 다르게 Wofi는 모든 목록이 필요 ---
ALL_DESKTOP_PATHS=$(find /usr/share/applications/ ~/.local/share/applications/ -name "*.desktop")
MATCHING_PATHS=$(grep -l "MimeType=.*;$CURRENT_MIME;.*" $ALL_DESKTOP_PATHS 2>/dev/null)

SORTED_ALL=$(echo -e "$ALL_DESKTOP_PATHS" | sort)
SORTED_MATCHING=$(echo -e "$MATCHING_PATHS" | sort)
NON_MATCHING_PATHS=$(comm -3 <(echo -e "$SORTED_ALL") <(echo -e "$SORTED_MATCHING"))

# Wofi 출력 형식 생성
APP_NAMES=""
for full_path in $MATCHING_PATHS; do APP_NAMES="$APP_NAMES$(grep "^Name=" "$full_path" | cut -d'=' -f2 | head -n 1 | tr -d '\n')\n"; done
APP_NAMES="$APP_NAMES----------\n"
for full_path in $NON_MATCHING_PATHS; do APP_NAMES="$APP_NAMES$(grep "^Name=" "$full_path" | cut -d'=' -f2 | head -n 1 | tr -d '\n')\n"; done


# 4. Wofi 실행 및 선택 처리
SELECTED_NAME=$(echo -e "$APP_NAMES" | wofi -d -p "기본 앱 선택 / Select Default App for $CURRENT_MIME:")

if [ -n "$SELECTED_NAME" ]; then
    CLEAN_NAME=$(echo "$SELECTED_NAME" | tr -d '\n')
    SELECTED_PATH=$(grep "^$CLEAN_NAME:" "$MAP_FILE" | cut -d':' -f2- | head -n 1 | tr -d '\n')
    
    if [ -n "$SELECTED_PATH" ] && [ "$SELECTED_PATH" != "/dev/null" ]; then
        APP_BASENAME=$(basename "$SELECTED_PATH")
        xdg-mime default "$APP_BASENAME" "$CURRENT_MIME"
        notify-send "Wodac 성공/Success" "기본 앱이 $APP_BASENAME 으로 설정되었습니다. (Default app set)"
    fi
fi

# 6. 임시 파일 정리
rm -f "$MAP_FILE"
]]

    -- 디렉토리가 없으면 생성
    run_cli("mkdir -p " .. shell.quote(INSTALL_DIR))

    -- 파일 쓰기 (Lua io 라이브러리 사용)
    local file = io.open(SCRIPT_PATH, "w")
    if file then
        file:write(script_content)
        io.close(file)
        -- 실행 권한 부여
        run_cli("chmod +x " .. shell.quote(SCRIPT_PATH))
        ya.notify("Wodac 설치됨", "wodac.sh 스크립트가 생성되었습니다.", "info", 3000)
    else
        ya.notify("Wodac 오류", "스크립트 파일을 생성할 수 없습니다.", "error", 3000)
    end
end

-- wodac.sh 실행 함수
local function run_wodac()
    local entry = ya.sync(function() return ya.current_entry() end)
    if not entry then
        ya.sync(function() ya.notify("Wodac 오류", "파일 선택 안 됨.", "error", 3000) end)
        return
    end
    
    local file_path_q = shell.quote(entry.url)
    
    -- 비동기 실행
    ya.exec("sh " .. SCRIPT_PATH .. " " .. file_path_q, true) 
end

-- 플러그인 노출
return {
    install = install_script,
    wodac = run_wodac,
}
